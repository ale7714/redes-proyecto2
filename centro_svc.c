/* 
 * Universidad Simón Bolivar
 * CI4835 - Redes de Computadoras
 * Proyecto 2
 * 
 * Archivo:     centro_svc.c
 * Autor:       Alexandra Paredes 05-38680
 *              Javier Rodriguez  05-38838
 * Descripción: Programa que implemente las funciones del centro de distriucion (servidor)
 * 
 */

/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */


#include "centro.h"
#include <stdio.h>
#include <stdlib.h>
#include <rpc/pmap_clnt.h>
#include <string.h>
#include <memory.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include "gestion_centro.h"

#ifndef SIG_PF
#define SIG_PF void(*)(int)
#endif


char entryLog[256];

////////////////////////// INICIO FUNCIONES MANEJO DE LA LISTA ////////////////////////////////////

/*  Función: crear
    Entrada:
        lista: Apuntador a la dirección en memoria de la lista
    Salida:
        N/A 
    Función que crea la lista que almacena tipo bomba
*/
void crear(bomba* lista){
    strcpy(lista->nombre,"NIL");
    strcpy(lista->desafio,"NIL"); 
    lista->tiempoVencimiento = 0; 
    lista->siguiente = NULL; 
}

///////////////////////////// FIN FUNCIONES MANEJO DE LA LISTA ////////////////////////////////////


/*  Función: centro_prog_1
    Entrada:
        rqstp: Apuntador a la structura svc_req
        transp: Apuntador al registro SVCXPRT
    Salida:
        N/A 
    Función que gestiona las funciones del RPC del lado del servidor
*/
static void centro_prog_1(struct svc_req *rqstp, register SVCXPRT *transp){

	union {
		datos solicitar_desafio_1_arg;
		datos respodnder_desafio_1_arg;
		char *solicitar_tiempo_1_arg;
		char *solicitar_gasolina_1_arg;
	} argument;
	char *result;
	xdrproc_t _xdr_argument, _xdr_result;
	char *(*local)(char *, struct svc_req *);

	switch (rqstp->rq_proc) {
	case NULLPROC:
		(void) svc_sendreply (transp, (xdrproc_t) xdr_void, (char *)NULL);
		return;

	case SOLICITAR_DESAFIO:
		_xdr_argument = (xdrproc_t) xdr_datos;
		_xdr_result = (xdrproc_t) xdr_wrapstring;
		local = (char *(*)(char *, struct svc_req *)) solicitar_desafio_1_svc;
		break;

	case RESPODNDER_DESAFIO:
		_xdr_argument = (xdrproc_t) xdr_datos;
		_xdr_result = (xdrproc_t) xdr_wrapstring;
		local = (char *(*)(char *, struct svc_req *)) respodnder_desafio_1_svc;
		break;

	case SOLICITAR_TIEMPO:
		_xdr_argument = (xdrproc_t) xdr_wrapstring;
		_xdr_result = (xdrproc_t) xdr_int;
		local = (char *(*)(char *, struct svc_req *)) solicitar_tiempo_1_svc;
		break;

	case SOLICITAR_GASOLINA:
		_xdr_argument = (xdrproc_t) xdr_wrapstring;
		_xdr_result = (xdrproc_t) xdr_int;
		local = (char *(*)(char *, struct svc_req *)) solicitar_gasolina_1_svc;
		break;

	default:
		svcerr_noproc (transp);
		return;
	}
	memset ((char *)&argument, 0, sizeof (argument));
	if (!svc_getargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
		svcerr_decode (transp);
		return;
	}
	result = (*local)((char *)&argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, (xdrproc_t) _xdr_result, result)) {
		svcerr_systemerr (transp);
	}
	if (!svc_freeargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
		fprintf (stderr, "%s", "unable to free arguments");
		exit (1);
	}
	return;
}

/*  Función: verificarArgs  
    Entrada:
        cantArg: Cantidad de parametros introducidos.
           args: Arreglo con los parametros introducidos.
    Salida:
        N/A 
    Función que permite verificar los parametros de entrada al llamar
    el programa. En caso de diferencias con el formato de 
    entrada se muestra el mensaje de uso del progama
*/
void verificarArgs(int cantArg,char*args[]){
    int opt;

    struct option longopts[] = {
       { "cp", required_argument, NULL, 'm'},
       { 0, 0, 0, 0}
    };

    if(cantArg == 11){

        /* Ciclo que toma los arguemtos de cada uno de los flags sin importar el orden en
           el cual son colocado los flags al invocar el programa */
        while ((opt = getopt_long_only(cantArg, args, "n:m:i:t:s:",longopts,NULL)) != -1){

            switch (opt) {
                case 'n':
                    // Nombre del Centro
                    if (nombreServidor != NULL) 
                        free(nombreServidor);
                    if (asprintf(&nombreServidor, "%s", optarg) == -1) {
                            fatalerror("Error copiando string para manejo de argumentos",
                                EXIT_BAD_ARG);
                    }
                    //printf("Nombre: %s\n",nombreCentro);
                    break;

                case 'm':
                    // Capacidad Máxima
                    capacidadMaximaServidor = atoi(optarg);
                    //printf("Capacidad: %d\n",capacidadMaxima);
                    break;

                case 'i':
                    // Inventario
                    inventarioServidor = atoi(optarg);
                    //printf("Inventario: %d\n",inventario);
                    break;

                case 't':
                    // Tiempo de respuesta
                    tiempoRespuestaServidor = atoi(optarg);
                    //printf("Tiempo: %d\n",tiempo);
                    break;

                case 's':
                    // Suministro
                    suministroServidor = atoi(optarg);
                    //printf("Suministro: %d\n",suministro);
                    break;

                default:
                       fatalerror(usoCentro,EXIT_BAD_ARG);
            }

        }
        if(capacidadMaximaServidor < 38000 || capacidadMaximaServidor > 3800000){
            fatalerror(usoCentro,EXIT_BAD_ARG);
        }
        if(inventarioServidor < 0 || inventarioServidor > capacidadMaximaServidor){
            fatalerror(usoCentro,EXIT_BAD_ARG);
        }
        if(suministroServidor < 0 || suministroServidor > 10000){
            fatalerror(usoCentro,EXIT_BAD_ARG);
        }
        if(tiempoRespuestaServidor < 0 || tiempoRespuestaServidor > 180){
            fatalerror(usoCentro,EXIT_BAD_ARG);
        }
    }else{
        fatalerror(usoCentro,EXIT_BAD_ARG);
    } 
}

/*  Función: finHilo
    Entrada:
        signal: Entero que representa la señal de retorno del hilo
    Salida:
        N/A
    Función que verfica si el tanque esta o no full
*/
static void finHilo(int signal){

    if (fclose(logServer) == 0){

        printf("Termino actividad del servidor.\n");

    }

    exit(0);

}

/*  Función: ejecucionCentro
    Entrada:
        N/A
    Salida:
        N/A
    Función que se encarga de hacer la simulación del tiempo. 
    Verifica que el tanque este lleno o vacío y hace el aumento de gasolina, cuando sea necesario. 
*/
void *ejecucionCentro(){

    while(tiempoEjecucionServidor<=480){

        if(inventarioServidor == capacidadMaximaServidor){
            sprintf(entryLog, "Tanque full: %d\n", tiempoEjecucionServidor);
            fprintf(logServer,"%s",entryLog);
            fflush(logServer);
        }

        if(inventarioServidor <= 0){
            sprintf(entryLog, "Tanque vacio: %d\n", tiempoEjecucionServidor);
            fprintf(logServer,"%s",entryLog);
            fflush(logServer);
        }

        tiempoEjecucionServidor++;
        if((inventarioServidor = inventarioServidor + suministroServidor) > capacidadMaximaServidor){
            inventarioServidor = capacidadMaximaServidor;
        }
        //printf("Inventario %d\n",inventarioServidor);

        usleep(100*1000);
    }

    raise(SIGUSR1);
}

int main (int argc, char **argv)
{
	pthread_t threadPrincipal = (pthread_t *) malloc(sizeof (pthread_t));

    struct sigaction accion;
    memset(&accion,'\0',sizeof(accion));
    accion.sa_handler = &finHilo;

    tiempoEjecucionServidor = 0;

    programname = argv[0]; // Guardar nombre del programa para errores

    if(sigaction(SIGUSR1, &accion, NULL) < 0) {
        fatalerror("Manejando la señal",EXIT_ERROR);
        return 1;
    }

    verificarArgs(argc,argv);

    listaBombas = (bomba *) malloc(sizeof(bomba));
    crear(listaBombas);
    
    // Crear y abrir archivo en modo de escritura
    char log_name[128];
    sprintf(log_name, "log_%s.txt", nombreServidor);
    logServer = fopen(log_name, "w");
    fprintf(logServer, "\0");
    fclose(logServer);
    logServer = fopen(log_name, "a+");

    // Escribir estado inicial del centro en el log
    sprintf(entryLog, "Estado incial: %d\n", inventarioServidor);
    fprintf(logServer,"%s",entryLog);
    fflush(logServer);

    int tError;
    if((tError=pthread_create(&threadPrincipal,NULL,ejecucionCentro,NULL)) < 0)
        fatalerror("Error al crear el thread",tError); 


	register SVCXPRT *transp;

	pmap_unset (CENTRO_PROG, CENTRO_VERS);

	transp = svcudp_create(RPC_ANYSOCK);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create udp service.");
		exit(1);
	}
	if (!svc_register(transp, CENTRO_PROG, CENTRO_VERS, centro_prog_1, IPPROTO_UDP)) {
		fprintf (stderr, "%s", "unable to register (CENTRO_PROG, CENTRO_VERS, udp).");
		exit(1);
	}

	transp = svctcp_create(RPC_ANYSOCK, 0, 0);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create tcp service.");
		exit(1);
	}
	if (!svc_register(transp, CENTRO_PROG, CENTRO_VERS, centro_prog_1, IPPROTO_TCP)) {
		fprintf (stderr, "%s", "unable to register (CENTRO_PROG, CENTRO_VERS, tcp).");
		exit(1);
	}

	svc_run ();
	fprintf (stderr, "%s", "svc_run returned");



    exit(EXIT_SUCCESS);
}
